# -*- coding: utf-8 -*-
"""
Created on Wed Apr 15 11:23:26 2020


"""



# -*- coding: utf-8 -*-
"""
Created on Thu Jul 11 13:36:39 2019

@author: mshandhi3
"""


"""
#this code is to get classification results from HP2E data using SVM and other classifier.
#train and test using loso cross-validation, for testing get maximum number of vote for the data points per subject and
# use that as predicted class.

"""

import numpy
import numpy as np # linear algebra
import pandas as pd # data processing, CSV file I/O (e.g. pd.read_csv)
import scipy as sp
import collections
from mpl_toolkits.axes_grid1 import host_subplot
import mpl_toolkits.axisartist as AA
import matplotlib.pyplot as plt
from sklearn.preprocessing import LabelEncoder
from sklearn.metrics import r2_score
from sklearn.decomposition import PCA, FastICA
import xgboost as xgb
#import xgboost
from sklearn import metrics
from sklearn.metrics import classification_report
from sklearn.metrics import roc_auc_score
from sklearn.model_selection import KFold
from sklearn.metrics import mean_squared_error
from sklearn.model_selection import LeaveOneGroupOut
from sklearn.manifold import TSNE
import itertools
from sklearn import preprocessing
from itertools import cycle
from sklearn.linear_model import LogisticRegression
from sklearn import neighbors
from sklearn.ensemble import ExtraTreesClassifier
from sklearn import svm
from sklearn.ensemble import RandomForestClassifier
from sklearn.ensemble import RandomForestRegressor
from sklearn.ensemble import ExtraTreesRegressor
from sklearn.svm import LinearSVR
from sklearn import linear_model
from sklearn.linear_model import ElasticNet
from sklearn.ensemble import BaggingRegressor
from sklearn.tree import DecisionTreeRegressor
from sklearn.neighbors import KNeighborsRegressor
from sklearn.ensemble import AdaBoostRegressor
from sklearn.ensemble import GradientBoostingRegressor
from sklearn.cluster import KMeans
from sklearn.random_projection import GaussianRandomProjection
from sklearn.random_projection import SparseRandomProjection
from sklearn.decomposition import TruncatedSVD
from sklearn import cluster
import seaborn as sns
from sklearn import manifold
from sklearn import preprocessing
from scipy.spatial import distance
from sklearn.preprocessing import Imputer
from sklearn.preprocessing import StandardScaler, MinMaxScaler, MaxAbsScaler
from sklearn.impute import SimpleImputer
from scipy import signal
from scipy.signal import savgol_filter
from IPython import get_ipython
from scipy import stats
import csv
from matplotlib import pyplot
from sklearn.calibration import calibration_curve
from sklearn.svm import SVC
from sklearn.svm import LinearSVC
from imblearn.over_sampling import RandomOverSampler
from imblearn.over_sampling import SMOTE, ADASYN
from imblearn.over_sampling import BorderlineSMOTE
from imblearn.over_sampling import SVMSMOTE
from collections import Counter
from sklearn.metrics import roc_curve, auc
from sklearn.neighbors import KNeighborsClassifier
from sklearn.neural_network import MLPClassifier
from sklearn.model_selection import GroupKFold
from sklearn.model_selection import GridSearchCV
from sklearn.preprocessing import label_binarize
from sklearn.multiclass import OneVsRestClassifier
from scipy import interp
from sklearn.model_selection import train_test_split
from sklearn.feature_selection import SelectKBest,chi2, f_classif,  mutual_info_classif, RFE, SelectFromModel,SelectFdr
#import scikitplot as skplt

plt.rcParams.update({'figure.max_open_warning': 0})

def f_importances(coef, names):
    imp = coef
    imp,names = zip(*sorted(zip(imp,names)))
    plt.barh(range(len(names)), imp, align='center')
    plt.yticks(range(len(names)), names)
    plt.show()

def countX(lst, x): 
    return lst.count(x) 

def plot_roc_curve(fpr, tpr):  
    plt.plot(fpr, tpr, color='orange', label='ROC')
    plt.plot([0, 1], [0, 1], color='darkblue', linestyle='--')
    plt.xlabel('False Positive Rate')
    plt.ylabel('True Positive Rate')
    plt.title('Receiver Operating Characteristic (ROC) Curve')
    plt.legend()
    plt.show()

def perf_measure(y_actual, y_hat):
    TP = 0
    FP = 0
    TN = 0
    FN = 0

    for i in range(len(y_hat)): 
        if y_actual[i]==y_hat[i]==1:
           TP += 1
        if y_hat[i]==1 and y_actual[i]!=y_hat[i]:
           FP += 1
        if y_actual[i]==y_hat[i]==0:
           TN += 1
        if y_hat[i]==0 and y_actual[i]!=y_hat[i]:
           FN += 1

    return(TP, FP, TN, FN)


def bland_altman_plot(data1, data2, *args, **kwargs):
    data1     = np.asarray(data1)
    data2     = np.asarray(data2)
    mean      = np.mean([data1, data2], axis=0)
    diff      = data1 - data2                   # Difference between data1 and data2
    md        = np.mean(diff)                   # Mean of the difference
    sd        = np.std(diff, axis=0)            # Standard deviation of the difference

    plt.scatter(mean, diff, *args, **kwargs)
    plt.axhline(md,           color='gray', linestyle='--')
    plt.axhline(md + 1.96*sd, color='gray', linestyle='--')
    plt.axhline(md - 1.96*sd, color='gray', linestyle='--')

plt.close('all')
plt.interactive(False)

#get_ipython().run_line_magic('matplotlib', 'qt5')
#read dataset for Mac

# Read Dataset for Windows
#data_frame = pd.read_csv('D:\Onedrive Gatech\OneDrive - Georgia Institute of Technology\Research at Gatech\HP2E Data from UCSF\Analysis For Classification Journal\Feature File\HP2E Features 82 files 20190710.csv')
#df=pd.read_csv('D:\Onedrive Gatech\OneDrive - Georgia Institute of Technology\Documents\Mousumi\code\nusrat_1000sample_dataset.csv')
#df=pd.read_csv('nusrat_1000sample_dataset.csv')
df=pd.read_csv('nusrat_all_dataset.csv')

feature_set = list(df.columns.values) 
feature_set.remove('Class')
X=(df.drop(columns=['Class'])).values
Y=(df['Class'])

# drop rows with nan

Y=Y[~np.isnan(X).any(axis=1)]
X=X[~np.isnan(X).any(axis=1)]

y= np.zeros(Y.shape)
class_names=list(np.unique(Y))
class_num=0
number_of_classes=np.unique(Y).shape[0]
for classes in np.unique(Y):
    y[Y==classes]=int(class_num)
    print('Class '+ classes + ': ' + str(class_num))
    class_num=class_num+1

X = StandardScaler().fit_transform(X) #### for anaova
#X = MinMaxScaler().fit_transform(X) #### for Chi2

## Select features
fdr = SelectFdr(f_classif,alpha=0.005) #### for anaova
#fdr = SelectFdr(chi2,alpha=0.05) #### for Chi2
X_select = fdr.fit_transform(X,y)

#####to select top 100 features############
X_select = SelectKBest(f_classif,k=100).fit_transform(X_select,y)
#X_select = SelectKBest(chi2,k=100).fit_transform(X_select,y)

idx_sorted = fdr.get_support(indices = True)
pvals = fdr.pvalues_
pscores = fdr.scores_

print (X.shape)
print (X_select.shape)


select_features = list( feature_set[i] for i in idx_sorted)
print ('Selected features: ')
print  (select_features)
print ('\n')


X=X_select

    

# Binarize the output
#y = label_binarize(y, classes=[0, 1, 2])
#n_classes = y.shape[1]

lb = preprocessing.LabelBinarizer()
y = lb.fit_transform(y)
n_classes = y.shape[1]



    
###################################### classifier#########################################    


#initialize a vector to collect all "out of fold" predictions
y_predicted = np.zeros(y.shape)
y_predicted_prob = np.zeros(y.shape)
#status_predictions = np.zeros((status_modified.shape[0],2)) # for xgboost
#status_predictions_prob = np.zeros((status.shape[0],np.unique(status).shape[0]))

random_state = np.random.RandomState(0)
#logo = LeaveOneGroupOut()

kf = KFold(n_splits=10)
#kf.get_n_splits(X,y)
fold=0

for train, test in kf.split(X):

    #perform train test split for the current fold
    X_train, X_test, y_train, y_test = X[train], X[test], y[train], y[test]
#    X_train, X_test = X[train], X[test]
#    y_train, y_test = y[train], y[test]




    #standardize training and testing data
#    scaler = preprocessing.StandardScaler().fit(X_train)
#    X_train=scaler.transform(X_train)
#    X_test=scaler.transform(X_test)
#    mean_train = np.mean(X_train, axis=0)
#    std_train = np.std(X_train, axis=0)
    
#    X_train = (X_train - mean_train)/std_train
#    X_test = (X_test - mean_train)/std_train
    
    
    # oversample
    
#    ros = RandomOverSampler(random_state=0)
#    X_resampled, y_resampled = ros.fit_resample(X_train, y_train)
    
#    X_resampled, y_resampled = SMOTE().fit_resample(X_train, y_train)
    
#    X_resampled, y_resampled = BorderlineSMOTE().fit_resample(X_train, y_train)
#    X_resampled, y_resampled = SVMSMOTE().fit_resample(X_train, y_train)
#    X_resampled, y_resampled = ADASYN(random_state=random_state).fit_resample(X_train, y_train)
    
#    print("Before Resampling:",sorted(Counter(y_train).items()))
#    print("After Resampling:",sorted(Counter(y_resampled).items()))
    #Create a svm Classifier
#    clf = svm.SVC(kernel='linear') # Linear Kernel
    
    
#    clf=svm.SVC(gamma='auto') #rbf kernel # best result so far
#    clf=svm.SVC(gamma='auto',probability=True,random_state=random_state)
#    clf=svm.SVC(gamma='scale',probability=True,random_state=random_state)
#    
    ####### SVM with RBF Kernel ###################
#    clf = OneVsRestClassifier(svm.SVC(kernel='rbf', probability=True,gamma='auto',class_weight='balanced',
#                                 random_state=random_state))

    ####### SVM with Polynomial Kernel ###################
#    clf = OneVsRestClassifier(svm.SVC(kernel='poly', probability=True,gamma='auto',class_weight='balanced',
#                                 random_state=random_state))


    ####### SVM with Polynomial Kernel ###################
#    clf = OneVsRestClassifier(svm.SVC(kernel='linear', probability=True,class_weight='balanced',
#                                 random_state=random_state))####### SVM with Polynomial Kernel ###################
    
    ####### Random Forest ###################
#    clf = OneVsRestClassifier(RandomForestClassifier(n_estimators = 100,  random_state= random_state, max_features = 'sqrt',n_jobs=-1))

 # best grid for f1 Best Grid {'max_depth': 20, 'n_estimators': 50}
    clf = OneVsRestClassifier(RandomForestClassifier(n_estimators = 50, max_depth=20,  random_state= random_state, max_features = 'sqrt',n_jobs=-1))
#    #   #    
#    clf = RandomForestClassifier(n_estimators = 100,   random_state= random_state, max_features = 'sqrt',n_jobs=-1)
    
#    
#    clf = MLPClassifier(solver='lbfgs', alpha=1e-5,hidden_layer_sizes=(5, 2), random_state=1)
#    clf = MLPClassifier(solver='lbfgs', alpha=1e-5, random_state=1)
#    clf = MLPClassifier(solver='sgd', alpha=1e-5, random_state=1,max_iter=100000)
#    clf = MLPClassifier(solver='lbfgs', alpha=1e-5, random_state=1,max_iter=100000)
    
#    clf=svm.SVC(gamma='auto',kernel='poly')
    
#    clf = KNeighborsClassifier(n_neighbors=5,n_jobs=-1)
#    clf=svm.SVC(gamma=0.1) #rbf kernel
#    clf = LogisticRegression(random_state=0, solver='sag', multi_class='ovr',max_iter=1000,n_jobs=-1).fit(X_resampled, y_resampled)
#    clf=RandomForestClassifier(n_estimators = 1000,  max_depth=20, random_state= 42, max_features = 'sqrt',n_jobs=-1)
#    clf=RandomForestClassifier(n_estimators = 2000,  max_depth=20, random_state= 42, max_features = 'sqrt',n_jobs=-1)
#    clf=RandomForestClassifier(n_estimators = 50,  max_depth=5, random_state= 42, max_features = 'sqrt',n_jobs=-1)



    
    
#    y_prob = clf.fit(X_train, y_train).decision_function(X_test)
    y_prob = clf.fit(X_train, y_train).predict_proba(X_test)
#    y_prob = clf.fit(X_train, y_train).oob_decision_function(X_test)
    y_pred = clf.fit(X_train, y_train).predict(X_test)

#   




    
    # classification code again
    y_predicted[test,:] = y_pred
  
    
    
    y_predicted_prob[test,:] = y_prob
    

    
    target_names = class_names # classes from original class
    print('For Fold: '+str(fold) +'\n')
    print(classification_report(y_test, y_pred, target_names=target_names))
    fold=fold+1



    




# Compute ROC curve and ROC area for each class
fpr = dict()
tpr = dict()
roc_auc = dict()
for i in range(n_classes):
    fpr[i], tpr[i], _ = roc_curve(y[:, i], y_predicted_prob[:, i])
    roc_auc[i] = auc(fpr[i], tpr[i])

# Compute micro-average ROC curve and ROC area
fpr["micro"], tpr["micro"], _ = roc_curve(y.ravel(), y_predicted_prob.ravel())
roc_auc["micro"] = auc(fpr["micro"], tpr["micro"])

#Plot of a ROC curve for a specific class
plt.figure()
lw = 2
plt.plot(fpr[2], tpr[2], color='darkorange',
         lw=lw, label='ROC curve (area = %0.2f)' % roc_auc[2])
plt.plot([0, 1], [0, 1], color='navy', lw=lw, linestyle='--')
plt.xlim([0.0, 1.0])
plt.ylim([0.0, 1.05])
plt.xlabel('False Positive Rate')
plt.ylabel('True Positive Rate')
plt.title('Receiver operating characteristic example')
plt.legend(loc="lower right")
plt.show()

# Compute macro-average ROC curve and ROC area
from matplotlib.font_manager import FontProperties

fontP = FontProperties()
fontP.set_size('small')
#legend([plot1], "title", prop=fontP) 
# First aggregate all false positive rates
all_fpr = np.unique(np.concatenate([fpr[i] for i in range(n_classes)]))

# Then interpolate all ROC curves at this points
mean_tpr = np.zeros_like(all_fpr)
for i in range(n_classes):
    mean_tpr += interp(all_fpr, fpr[i], tpr[i])

# Finally average it and compute AUC
mean_tpr /= n_classes

fpr["macro"] = all_fpr
tpr["macro"] = mean_tpr
roc_auc["macro"] = auc(fpr["macro"], tpr["macro"])

# Plot all ROC curves
plt.figure()
plt.plot(fpr["micro"], tpr["micro"],
         label='micro-avg ROC (area = {0:0.2f})'
               ''.format(roc_auc["micro"]),
         color='deeppink', linestyle=':', linewidth=4)

plt.plot(fpr["macro"], tpr["macro"],
         label='macro-avg ROC (area = {0:0.2f})'
               ''.format(roc_auc["macro"]),
         color='navy', linestyle=':', linewidth=4)

#colors = cycle(['aqua', 'darkorange', 'cornflowerblue','r','g','yellow',])
colors = cycle(['aqua', 'darkorange', 'cornflowerblue','r','g','y','m','b'])
for i, color in zip(range(n_classes), colors):
    plt.plot(fpr[i], tpr[i], color=color, lw=lw,
             label='ROC: class {0} (area = {1:0.2f})'
             ''.format(i, roc_auc[i]))

plt.plot([0, 1], [0, 1], 'k--', lw=lw)
plt.xlim([0.0, 1.0])
plt.ylim([0.0, 1.05])
plt.xlabel('False Positive Rate')
plt.ylabel('True Positive Rate')
#plt.title('ROC of SVM with Linear Kernel using Anova FDR Selected 100 Features')
plt.title('ROC of RF using Anova FDR Selected 100 Features')
plt.legend(loc="lower right",prop=fontP)
plt.savefig('D:\Onedrive Gatech\OneDrive - Georgia Institute of Technology\Documents\Mousumi\Figures\ROC_RF_All_Data_with_Anova_FDR_100_F1.jpg', format = 'jpg' , dpi=1000)
plt.show()


######################print classification report #############################

target_names = class_names # classes from original class
print(classification_report(y, y_predicted, target_names=target_names))

#
##
#
#
#
#
#
#
